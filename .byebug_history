continue
::Services::Post::SNodesUpdater::PostTests.update_when_post_test_thumbnail_updated(post_test)
continue
Services::Post::SNodesUpdater::PostTest
Services::Post::SNodesUpdater
Services::Post::SNodesUpdater::PostTest.prepare_s_nodes
Services::Post::SNodesUpdater::PostTest.preapre_s_nodes
Services::Post::SNodesUpdater::PostTest.update_when_post_test_updated
continue
s_nodes[0]['node']['vote_poll_options']
continue
s_nodes[0]['node']['vote_poll_options']
s_nodes
continue
s_nodes
continue
post_vote_poll = post_vote_poll['node']
post_vote_poll['vote_poll_options']
post_vote_poll
continue
post.s_nodes = s_nodes.to_json
s_post_vote_poll['node']['vote_poll_options'].delete_if {|vo| vo['id']==vote_poll_option_id}
s_post_vote_poll['node']['vote_poll_options']
s_post_vote_poll['node']
s_post_vote_poll
s_post_vote_poll = s_nodes.find {|node| node['node_id'] == post_vote_poll_id && node['node_type'] == 'PostVotePoll' }
s_post_vote_poll = s_nodes.find {|node| node['node_id'] == post_vote_poll_id }
s_nodes[0]['node']['vote_poll_options']
continue
s_nodes[0]['node']['vote_poll_options']
continue
post= nil
s_nodes[0]['node']['vote_poll_options']
continue
s_nodes[0]['node']['vote_poll_options']
s_nodes[0]['node']
s_nodes[0]['node']['vote_poll_options']
s_nodes[0]['node']
s_nodes[0]
s_nodes
s_nodes[0]['nodes']['vote_poll_options']
continue
@vote_poll_option.errors
@vote_poll_option.validate
@vote_poll_option.errors
continue
@post_vote_poll.vote_poll_options.length
@post_vote_poll.has_custom_errors?
continue
@post_vote_poll.has_custom_errors?
continue
@post_vote_poll.vote_poll_options.length < 3
continue
@post_vote_poll.validation_service.set_attributes(:vote_poll_option_to_be_deleted).validate
@post_vote_poll.validation_service.set_attribute(:vote_poll_option_to_be_deleted).validate
@post_vote_poll.validation_service.set_attributes(:vote_poll_option_to_be_deleted).validate
@post_vote_poll.validation_service.set_scenarios(:vote_poll_option_to_be_deleted).validate
@post_vote_poll.validation_services.set_scenarios(:vote_poll_option_to_be_deleted).validate
@post_vote_poll.vote_poll_options.first.destroy
@post_vote_poll.vote_poll_options.map(&:content)
@post_vote_poll.vote_poll_options.map(:content)
@post_vote_poll.vote_poll_options.length
@post_vote_poll.vote_poll_options.length < 3
continue
@post_vote_poll.vote_poll_options.length < 2
@post_vote_poll.has_custom_errors?
continue
x['vote_poll_options']
x = s_nodes.find {|node| node['node_id'] == post_vote_poll_id && node['node_type'] == 'PostVotePoll'}
s_nodes.find {|node| node['node_id'] == post_vote_poll_id && node['node_type'] == 'PostVotePoll'}
s_nodes.find {|node| node['node_id'] == post_vote_poll_id}
continue
s_nodes
continue
post_node.node
post_node
continue
position
continue
s_nodes
s_nodes[0]['node'].delete('k')
s_nodes[0]
s_nodes[0]['post_node']
s_nodes[0]['post_node'].delete('k')
post.s_nodes
continue
post.s_nodes
post
post.s_nodes
post
continue
post.s_nodes
s_nodes
post.s_nodes
post
continue
@permitted_attributes
@post_text
continue
image.file_url
image.post_size_url
image.file
image.file_url
image.save
image.file_url
image.file = url
image = PostImage.new
url = @params['url']
@params['url']
@params['ur;']
continue
@params["url"]
@params
params
continue
@post_karma.count
continue
@post_karma.count
continue
post_karma_transaction
@post_karma_transaction
continue
@permitted_attributes['amount'].class
@post_karma_transaction
@permitted_attributes['amount']
continue
e
continue
e
continue
self.name
UserRole::PERMITTED_GLOBAL_ROLE_NAMES.include?(self.name)
UserRole::PERMITTED_GLOBAL_ROLE_NAMES
PERMITTED_GLOBAL_ROLE_NAMES
UserRole::ADMIN
UserRole::Admin
UserRole::PERMITTED_GLOBAL_ROLE_NAMES)
continue
@user.user_credential.errors
@user.user_credential
@user
@user.user_credenatial.errors
e
continue
e
continue
@user.user_credential.errors
@user.errors
e
continue
e
continue
e
@user.error
continue
@current_user.id.to_s
@current_user.id
params['user_id']
continue
e
continue
e.attributes
e
@user.valid?
@user.errors
continue
Notification.where(user_id: current_user.id).map(&:created_at)
Notification.where("user_id = ? and created_at < ?", current_user.id, DateTime.parse(last_date))
DateTime.parse(last_date)
x = Time.new(last_date)
last_date
continue
x = Time.new(last_date)
last_date
continue
@model.file.url
@model.file
continue
@discussion
x
x = Discussion.last
Discussion.last
Discussion.last.messages_count
Discussion.last
@discussion.messages_count
@discussion
continue
json_node
continue
@params['personality_test_id']
@test_question.post_test.id == @params['personality_test_id']
@test_question.post_test.id
@params
continue
@test_answer_variant.personality_scales
continue
personality_scales
personality_scaels
@model.test_question_id
personalities
continue
@params[]
attributes
continue
va.as_json(include: [:content, :personality_scales])
va = test_answer_variant
continue
personality_scale_attributes
continue
sc.first
sc = vars.first.personality_scales
vars.first.personality_scales
vars = @model.test_answer_variants
personalities_ids
continue
@p_t_personality_to_destroy.destroy!
@p_t_personality_to_destroy.valid?
@p_t_personality_to_destroy.custom_errors
continue
x.size < 3
x.size
x = @model.post_test.p_t_personalities
continue
@personality.save!
@personality.custom_errors
continue
@model.as_json { methods: [:errors], include: [:personality_scales, {methods}] }
      ]
        }
          methods: [:base_url]
        {
        :personality_scales,
      include: [
      methods: [:errors],
@model.as_json {
@model.as_json({methods: [:errors], include: [{personality_scales: {methods: [:errors]}]}})
@model.as_json({methods: [:errors], include: {personality_scales: {methods: [:errors]}}})
@model.as_json({methods: [:errors], include: {personality_scales: {}}})
@model.as_json({methods: [:errors]})
@model.personality_scales
@model.as_json(error_options)
@model.as_json
continue
@model.errors
@model
continue
post_test.save
post_test.is_personality = true
post_test.user_id
post_test = PostTest.find(post_test_id)
continue
params
params['post_test_id']
continue
x.errors.to_json
x.errors.to_s
